
队列（Queue）
Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步



# 用栈实现队列
# 队列是一种先进先出(first in - first out，FIFO)的数据结构，队列中的元素都从后端(rear)入队(push)，从前端(front)出队(pop)
# 栈是一种后进先出(last in - first out，LIFO)的数据结构，栈中元素从栈顶(top)压入(push)，也从栈顶弹出(pop)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]


class MyQueue(object):

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, x):
        self.stack1.append(x)

    def pop(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def peek(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]

    def empty(self):
        return not self.stack1 and not self.stack2

class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = []

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.queue.append(x)

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        return self.queue.pop(0)

    def peek(self) -> int:
        """
        Get the front element.
        """
        return self.queue[0]

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return False if self.queue else True


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

54张牌分成三份，4个A一起的概率？0.02902757619738752
这个古典概率怎么算？求大佬指导一下小学生题
(18*17*16*15*50!*3)/54!


132、分割回文串II
给你一个字符串s，请你将s分割成一些子串，使每个子串都是回文，返回符合要求的最少分割次数

class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        g = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                g[i][j] = (s[i] == s[j]) and g[i + 1][j - 1]

        f = [float("inf")] * n
        for i in range(n):
            if g[0][i]:
                f[i] = 0
            else:
                for j in range(i):
                    if g[j + 1][i]:
                        f[i] = min(f[i], f[j] + 1)

        return f[n - 1]

it = (print("{}".format(i+1)) for i in range(2))  # "123"
first = next(it)
second = next(it)

当key不存在的时候，会调用这个工厂函数来生成key对应的value
应该是value不存在

标题前有空行错误：
函数返回值和作用域

reture退出了整个函数，相当于有break的作用else？？？？

自建函数del(index)		del语句
可以使用global和nolocal赋值  nonlocal

在python中，引用类型在创建对象时，都会开辟一个存储空间，不管元素是不是相同。它不像非引用类型一样，相同元素都是指向同一内存地址
列表和字典就是引用类型，修改元素只是在存储空间里面修改了值的引用，内存地址不变，只是元素的引用内存地址变了
https://blog.csdn.net/fm345689/article/details/88385963


224. 基本计算器

实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。

 

示例 1：

输入：s = "1 + 1"
输出：2
示例 2：

输入：s = " 2-1 + 2 "
输出：3
示例 3：

输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
 

提示：

1 <= s.length <= 3 * 105
s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
s 表示一个有效的表达式

class Solution(object):
    def calculate(self, s):
        res, num, sign = 0, 0, 1
        stack = []
        for c in s:
            if c.isdigit():
                num = 10 * num + int(c)
            elif c == "+" or c == "-":
                res += sign * num
                num = 0
                sign = 1 if c == "+" else -1
            elif c == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
            elif c == ")":
                res += sign * num
                num = 0
                res *= stack.pop()
                res += stack.pop()
        res += sign * num
        return res


227. 基本计算器 II
给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。



示例 1：

输入：s = "3+2*2"
输出：7
示例 2：

输入：s = " 3/2 "
输出：1
示例 3：

输入：s = " 3+5 / 2 "
输出：5


提示：

1 <= s.length <= 3 * 105
s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
s 表示一个 有效表达式
表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
题目数据保证答案是一个 32-bit 整数

class Solution:
    def calculate(self, s: str) -> int:
        return eval(s.replace('/', '//'))

s = "14-3/2"

def calculate(s):
	stack = []
	pre_op = "+"  # 记录前一个符号
	num = 0  # 记录前一个数字，多位数使用
	for i, c in enumerate(1, s):
		if c.isdigit():
			num = num * 10 + int(c)  # 拼接多位数
		# 当迭代到最后一位时，需要进行最后一次计算
		if i == len(s) - 1 or c in "+-*/":
			if pre_op == "+":
				stack.append(num)
			elif pre_op == "-":
				stack.append(-num)
			elif pre_op == "*":
				stack.append(stack.pop() * num)
			elif pre_op == "/":
				# 直接用int
				# stack.append(int(stack.pop() / num))
				top = stack.pop()
				# 负数向下整除
				if top < 0:
					# 如果是一个负数，先算除法在取反
					stack.append(-(-top // num))
				else:
					stack.append(top // num)
			pre_op = c
			num = 0
	return sum(stack)

print(calculate(s))


331. 验证二叉树的前序序列化
序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

     _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 "1,,3" 。

示例 1:

输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
示例 2:

输入: "1,#"
输出: false
示例 3:

输入: "9,#,#,1"
输出: false


tree = "9,3,4,#,#,1,#,#,2,#,6,#,#"
tree = "1,#,#,#,#"

def isValidSerialization(preorder):
	stack = []
	tree_list = preorder.split(",")
	for t in tree_list:
		stack.append(t)
		# 当栈长度大于2，且元素符合[数字, #, #]时，弹出两个栈顶，将第三个栈顶赋值"#"
		while len(stack) > 2 and stack[-3].isdigit() and stack[-2] == "#" and stack[-1] == "#":
			stack.pop()
			stack.pop()
			stack[-1] = "#"
		print(stack)
	# return True if len(stack) == 1 and stack[0] == "#" else False
	# return True if stack == ["#"] else False

print(isValidSerialization(tree))

class Solution(object):
    def isValidSerialization(self, preorder):
        stack = []
        for node in preorder.split(','):
            stack.append(node)
            while len(stack) >= 3 and stack[-1] == stack[-2] == '#' and stack[-3] != '#':
                stack.pop(), stack.pop(), stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack.pop() == '#'

tree = "9,3,4,#,#,1,#,#,2,#,6,#,#"
# tree = "1,#,#,#,#"

def isValidSerialization(preorder):
	nodes = preorder.split(',')
	# 在树中，所有节点的入度之和等于出度之和。diff = 出度 - 入度
	# 每个空节点（ "#" ）会提供 0 个出度和 1 个入度(叶子结点只有入没有出)
	# 每个非空节点会提供 2 个出度和 1 个入度(内部结点)
	diff = 1  # diff初始为1，因为，我们加入一个非空节点时，都会先减去一个入度，再加上两个出度。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，先减去一个入度，再加上两个出度，此时 diff 正好应该是2
	for node in nodes:
		diff -= 1
		if diff < 0:
			return False
		if node != '#':
			diff += 2
	return diff == 0

print(isValidSerialization(tree))

class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        """
        非空节点数量为 m，空节点数量为 n，在遍历没结束前恒成立：m>=n
        非空节点入度为1出度为2，空节点入度为1出度为0，初始化总入度为0总出度为1
        总入度为 m+n,总出度为2*m+1 可得 (2*m + 1)- (m+n) > 0
        故在遍历没有结束前总出度是一定大于总入度
        """
        ind, outd = 0, 1
        for i in preorder.split(','):
            if outd <= ind:
                return False
            ind += 1
            outd += 2 if i != "#" else 0
        return ind == outd


# 序列中：数字数量 = #号数量 - 1
# 在最后一个位置之前，数字数量 >= #号数量
# 由1和2可知，最后一个位置必为#号

记录数字数量 - #号数量就可以了。

例子
输入："9,3,4,#,#,1,#,#,2,#,6,#,#"
计数："1,2,3,2,1,2,1,0,1,0,1,0,-1"

输入："1,#"
计数："1,0" 违反1，数字数量 != #号数量-1

输入："9,#,#,1,#"
计数："1,0,-1,E,E" 违反2，当遍历到倒数第二个位置时已经非法，后面的输入无需再看
tree = "9,3,4,#,#,1,#,#,2,#,6,#,#"
tree = "7,#,#,2"

def isValidSerialization(preorder):
	degree = 1
	for node in preorder.split(','):
		if degree == 0:
			return False
		if node == '#':
			degree -= 1
		else:
			degree += 1
	return degree == 0

print(isValidSerialization(tree))


54. 螺旋矩阵
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

def spiralOrder(matrix):
	if not matrix or not matrix[0]:
		return []
	screw = []
	row, column = len(matrix), len(matrix[0])
	up, down, left, right = 0, row - 1, 0, column - 1
	x, y = 0, 0
	dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
	cur_d = 0
	while len(screw) != row * column:
		screw.append(matrix[x][y])
		if cur_d == 0 and y == right:
			cur_d += 1
			up += 1
		elif cur_d == 1 and x == down:
			cur_d += 1
			right -= 1
		elif cur_d == 2 and y == left:
			cur_d += 1
			down -= 1
		elif cur_d == 3 and x == up:
			cur_d += 1
			left += 1
		cur_d %= 4
		x += dirs[cur_d][0]
		y += dirs[cur_d][1]
	return screw

print(spiralOrder(matrix))

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()

        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 <= nextRow < rows and 0 <= nextColumn < columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()

        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom:
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order

此题直观感受类似"蛋糕卷"的展开,容易想到可以先将矩阵第一行取出后将剩下部分矩阵逆时针旋转90度并再次取出第一行拼接在其后,并重复这个过程,唯一的困难是"将矩阵逆时针旋转90度"的操作。

注意到python中zip(*matrix)是转置(i.e.绕主对角线做镜面对称)的常见写法,而matrix[::-1]可以实现矩阵绕水平对称轴做一次对称操作,而这两个操作的顺序叠加即是逆时针旋转90度

循环实现：
class Solution(object):
    def spiralOrder(self, matrix):
        tmp=[]
        while matrix:
            tmp+=list(matrix[0])
            matrix=list(zip(*(matrix[1:])))[::-1]
			# print(matrix, tmp)
        return tmp

递归
class Solution(object):
    def spiralOrder(self, matrix):
        if len(matrix)==1:
            return list(matrix[0])
        return list(matrix[0])+list(self.spiralOrder(list(zip(*(matrix[1:])))[::-1]))

zip函数，可用于转置矩阵

笔记疑问，所以一个名词查找顺序就是LEDG？？？


堂兄弟：D、E、F

子树不想交		相交

但完全二叉树不是满二叉树		不一定是

59. 螺旋矩阵 II
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

class Solution(object):
    def generateMatrix(self, n):
        if n == 0: return []
        res = [[0] * n for i in range(n)]
        left, right, up, down = 0, n - 1, 0, n - 1
        x, y = 0, 0
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        cur_d = 0
        count = 0
        while count != n * n:
            res[x][y] = count + 1
            count += 1
            if cur_d == 0 and y == right:
                cur_d += 1
                up += 1
            elif cur_d == 1 and x == down:
                cur_d += 1
                right -= 1
            elif cur_d == 2 and y == left:
                cur_d += 1
                down -= 1
            elif cur_d == 3 and x == up:
                cur_d += 1
                left += 1
            cur_d %= 4
            x += dirs[cur_d][0]
            y += dirs[cur_d][1]
        return res

class Solution(object):
    def generateMatrix(self, n):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        res = [[0] * n for i in range(n)]
        x, y = 0, 0
        count = 0
        cur_d = 0
        while count != n * n:
            res[x][y] = count + 1
            count += 1
            dx, dy = directions[cur_d][0], directions[cur_d][1]
            newx, newy = x + dx, y + dy
            if newx < 0 or newx >= n or newy < 0 or newy >= n or res[newx][newy] != 0:
                cur_d = (cur_d + 1) % 4
                dx, dy = directions[cur_d][0], directions[cur_d][1]
            x, y = x + dx, y + dy
        return res

n =3
a = [[0 for i in range(n)] for i in range(n)]
print(a)

b = [[0] * n for _ in range(n)]
print(b)
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]

115. 不同的子序列
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        #短的去匹配长的
        slen, tlen = len(s), len(t)
        dp = [[0 for _ in range(slen + 1)] for _ in range(tlen + 1)]    #虚指，好用一些

        for si in range(slen + 1):
            dp[0][si] = 1   #空串，是任何字符串的子串

        for i in range(1, tlen + 1):
            for j in range(1, slen + 1):    #递推关系式中，j依赖于j-1--->从左往右
                if t[i-1] == s[j-1]:
                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]    #不用s的这个字符 + 用s这个字符的情况
                else:
                    dp[i][j] = dp[i][j-1]   #s这个字符配不上，不用了

        return dp[tlen][slen]

class Solution:
    def numDistinct(self, s: str, t: str) -> int:

        dp = [[0]*(len(s) +1) for _ in range(len(t)+1)]

        for i in range(len(s)+1):
            dp[0][i] = 1

        for i in range(1,len(t)+1):
            for j in range(1,len(s)+1):
                if t[i-1] == s[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
                else:
                    dp[i][j] = dp[i][j-1]

        return dp[-1][-1]

方法一：动态规划
假设字符串 s 和 t 的长度分别为 mm 和 nn。如果 tt 是 ss 的子序列，则 ss 的长度一定大于或等于 tt 的长度，即只有当 m \ge nm≥n 时，tt 才可能是 ss 的子序列。如果 m<nm<n，则 tt 一定不是 ss 的子序列，因此直接返回 00。

当 m ≥ n 时，可以通过动态规划的方法计算在 ss 的子序列中 tt 出现的个数。

创建二维数组 \textit{dp}dp，其中 \textit{dp}[i][j]dp[i][j] 表示在 s[i:]s[i:] 的子序列中 t[j:]t[j:] 出现的个数。

class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        if m < n:
            return 0

        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][n] = 1

        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]
                else:
                    dp[i][j] = dp[i + 1][j]

        return dp[0][0]


class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        ls = len(s)
        lt = len(t)
        a = [0] * lt + [1]
        for i in range(ls):
            for j in range(lt-1, -1, -1):
                if s[i]==t[j]:
                    a[j] += a[j-1]
        return a[lt-1]

以下是代码分析：
s = "babgbag"
t = "bdg"

def numDistinct(s, t):
	ls = len(s)
	lt = len(t)
	a = [0] * lt + [1]  # 列表尾部的1用来提供初始相加值，即当索引j为0，j-1为-1，即尾部的1
	print(ls, lt, a)
	for i in range(ls):  # s从前向后迭代，出现相同的字符，次数加一次
		for j in range(lt - 1, -1, -1):  # t从后向前迭代，出现相同的字符，就在列表中记录一次
			print(i, j, s[i], t[j])
			if s[i] == t[j]:
				print(j, a[j], a[j - 1])
				a[j] += a[j - 1]  # 每多出现一次，子串个数就会在前面基础上多一次
			print(a)
	return a[lt - 1]

print(numDistinct(s, t))






92. 反转链表 II
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL

算法步骤：

第 1 步：先将待反转的区域反转；
第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ。


class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        def reverse_linked_list(head: ListNode):
            # 也可以使用递归反转一个链表
            pre = None
            cur = head
            while cur:
                next = cur.next
                cur.next = pre
                pre = cur
                cur = next

        # 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        dummy_node = ListNode(-1)
        dummy_node.next = head
        pre = dummy_node
        # 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        # 建议写在 for 循环里，语义清晰
        for _ in range(left - 1):
            pre = pre.next

        # 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        right_node = pre
        for _ in range(right - left + 1):
            right_node = right_node.next
        # 第 3 步：切断出一个子链表（截取链表）
        left_node = pre.next
        curr = right_node.next

        # 注意：切断链接
        pre.next = None
        right_node.next = None

        # 第 4 步：同第 206 题，反转链表的子区间
        reverse_linked_list(left_node)
        # 第 5 步：接回到原来的链表中
        pre.next = right_node
        left_node.next = curr
        return dummy_node.next

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseBetween(self, head, left, right):
        count = 1
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy
        while pre.next and count < left:
            pre = pre.next
            count += 1
        cur = pre.next
        tail = cur
        while cur and count <= right:
            nxt = cur.next
            cur.next = pre.next
            pre.next = cur
            tail.next = nxt
            cur = nxt
            count += 1
        return dummy.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        prehead = ListNode(0, head)
        cur = prehead
        for i in range(left - 1):
            cur = cur.next
        pre = cur
        cur = cur.next
        for i in range(right - left):
            oldhead = pre.next
            newhead = cur.next
            pre.next = newhead
            cur.next = newhead.next
            newhead.next = oldhead
        return prehead.next

1603. 设计停车系统
请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。

请你实现 ParkingSystem 类：

ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。
bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。一辆车只能停在  carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。


示例 1：

输入：
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
输出：
[null, true, true, false, false]


Parking = [1, 1, 0]

def addCar(carType):
	if Parking[carType - 1]:
		Parking[carType - 1] -= 1
		return True
	else:
		return False

print(addCar(1))
print(addCar(2))
print(addCar(3))
print(addCar(1))

class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.Parking = [big, medium, small]

    def addCar(self, carType: int) -> bool:
        if self.Parking[carType - 1]:  # 值大于零为真
            self.Parking[carType - 1] -= 1
            return True
        else:
            return False

class ParkingSystem(object):

    def __init__(self, big, medium, small):
        self.park = [0, big, medium, small]

    def addCar(self, carType):
        if self.park[carType] == 0:
            return False
        self.park[carType] -= 1
        return True


class ParkingSystem:

    def __init__(self, big: int, medium: int, small: int):
        self.big, self.medium, self.small = big, medium, small

    def addCar(self, carType: int) -> bool:
        if carType == 1 and self.big:
            self.big -= 1
            return True
        elif carType == 2 and self.medium:
            self.medium -= 1
            return True
        elif carType == 3 and self.small:
            self.small -= 1
            return True
        else:
            return False

191. 位1的个数
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。



提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

class Solution:
    def hammingWeight(self, n):
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count

class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i))
        return ret

class Solution(object):
    def hammingWeight(self, n):
        return bin(n).count("1")

class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            count += 1
            n &= n - 1
        return count

class Solution:
    def hammingWeight(self, n: int) -> int:
        res=0
        while n:
            res+=n&1
            n>>=1
        return res

456. 132 模式
给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。



进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？



示例 1：

输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
示例 2：

输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
示例 3：

输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。


提示：

n == nums.length
1 <= n <= 104
-109 <= nums[i] <= 109

class Solution(object):
    def find132pattern(self, nums):
        N = len(nums)
        numsi = nums[0]
        for j in range(1, N -1):
            for k in range(N -1, j, -1):
                if numsi < nums[k] and nums[k] < nums[j]:
                    return True
            numsi = min(numsi, nums[j])
        return False

class Solution(object):
    def find132pattern(self, nums):
        N = len(nums)
        leftMin = [float("inf")] * N
        for i in range(1, N):
            leftMin[i] = min(leftMin[i - 1], nums[i - 1])
        stack = []
        for j in range(N - 1, -1, -1):
            numsk = float("-inf")
            while stack and stack[-1] < nums[j]:
                numsk = stack.pop()
            if leftMin[j] < numsk:
                return True
            stack.append(nums[j])
        return False

个人感觉算法可以总结为：逆序寻找最大的值（3），同时存储第二大的值（2），遇到比2小值的即返回true

82. 删除排序链表中的重复元素 II
给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:

输入: 1->1->1->2->3
输出: 2->3


提示：

链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head

        dummy = ListNode(0, head)

        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur = cur.next

        return dummy.next

class Solution(object):
    def deleteDuplicates(self, head):
        if not head or not head.next:
            return head
        if head.val != head.next.val:
            head.next = self.deleteDuplicates(head.next)
        else:
            move = head.next
            while move and head.val == move.val:
                move = move.next
            return self.deleteDuplicates(move)
        return head

class Solution(object):
    def deleteDuplicates(self, head):
        if not head or not head.next:
            return head
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy
        cur = head
        while cur:
            while cur.next and cur.val == cur.next.val:
                cur = cur.next
            if pre.next == cur:
                pre = pre.next
            else:
                pre.next = cur.next
            cur = cur.next
        return dummy.next

class Solution:
    def deleteDuplicates(self, head):
        dummy = ListNode(0)
        dummy.next = head
        val_list = []
        while head:
            val_list.append(head.val)
            head = head.next
        counter = collections.Counter(val_list)
        head = dummy
        while head and head.next:
            if counter[head.next.val] != 1:
                head.next = head.next.next
            else:
                head = head.next
        return dummy.next

83. 删除排序链表中的重复元素
存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。

返回同样按升序排列的结果链表。



示例 1：

输入：head = [1,1,2]
输出：[1,2]

输入：head = [1,1,2,3,3]
输出：[1,2,3]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head

        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next

        return head

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        pre = head
        while pre and pre.next:
            if pre.val == pre.next.val:  # 如果数字出现了重复
                pre.next = pre.next.next  # 删除p.next
            else:
                pre = pre.next  # 后移，检查下一位
        return head

class Solution(object):
    def deleteDuplicates(self, head):
        if not head or not head.next:
            return head
        if head.val != head.next.val:
            head.next = self.deleteDuplicates(head.next)
        else:
            move = head.next
            while move.next and head.val == move.next.val:
                move = move.next
            return self.deleteDuplicates(move)
        return head

class Solution(object):
    def deleteDuplicates(self, head):
        if not head or not head.next: return head
        head.next = self.deleteDuplicates(head.next)
        return head if head.val != head.next.val else head.next

190. 颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。



提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


进阶:
如果多次调用这个函数，你将如何优化你的算法？



示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：

输入是一个长度为 32 的二进制字符串

class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        result = 0
        for i in range(32):
            result = (result << 1) + (n & 1)
            n >>= 1
        return result

class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for i in range(32):
            result <<= 1
            result += n & 1
            n >>= 1
        return result

class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        res = 0
        for i in range(32):
            res = (res << 1) | (n & 1)
            n >>= 1
        return res

class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        n = (n >> 16) | (n << 16);
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
        return n;

74. 搜索二维矩阵
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。


示例 1：
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
示例 2：
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
提示：

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-104 <= matrix[i][j], target <= 104


# 搜索二维矩阵，逐个迭代暴力求解
matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]
# target = 3
# target = 35
target = 65

def searchMatrix(matrix, target):
	m, n = len(matrix), len(matrix[0])
	for i in range(m):
		for j in range(n):
			# print(target, matrix[i][j])
			if target < matrix[i][j]:
				return False
			if target == matrix[i][j]:
				return True
			if target > matrix[i][j] and j == n - 2 and target < matrix[i][j + 1]:  # 要判断索引是否越界
				return False
	return False

# 搜索二维矩阵，逐行首尾判断迭代
print(searchMatrix(matrix, target))

matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]
target = 3

def searchMatrix(matrix, target):
	m, n = len(matrix), len(matrix[0])
	for i in range(m):
		# print(i)  # 行
		if matrix[i][0] <= target <= matrix[i][n - 1]:  # 在本行数值范围内
			for j in range(n):
				# print(target, matrix[i][j])
				if target == matrix[i][j]:
					return True
			return False  # 本行迭代完成后，未找到返回False
	return False  # 全部迭代完成后，未找到返回False

print(searchMatrix(matrix, target))

class Solution(object):
    def searchMatrix(self, matrix, target):
        return any(target in row for row in matrix)

class Solution(object):
    def searchMatrix(self, matrix, target):
        M, N = len(matrix), len(matrix[0])
        for i in range(M):
            for j in range(N):
                if matrix[i][j] == target:
                    return True
        return False

class Solution(object):
    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]:
            return False
        rows = len(matrix)
        cols = len(matrix[0])
        row, col = 0, cols - 1
        while True:
            if row < rows and col >= 0:
                if matrix[row][col] == target:
                    return True
                elif matrix[row][col] < target:
                    row += 1
                else:
                    col -= 1
            else:
                return False

class Solution(object):
    def searchMatrix(self, matrix, target):
        M, N = len(matrix), len(matrix[0])
        for i in range(M):
            if target > matrix[i][N - 1]:
                continue
            if target in matrix[i]:
                return True
        return False

class Solution(object):
    def searchMatrix(self, matrix, target):
        M, N = len(matrix), len(matrix[0])
        col0 = [row[0] for row in matrix]
        target_row = bisect.bisect_right(col0, target) - 1
        if target_row < 0:
            return False
        target_col = bisect.bisect_left(matrix[target_row], target)
        if target_col >= N:
            return False
        if matrix[target_row][target_col] == target:
            return True
        return False

import numpy as np
class Solution(object):
    def searchMatrix(self, matrix, target):
        matrix = np.reshape(matrix, [1, -1])
        return target in matrix

import numpy as np
class Solution(object):
    def searchMatrix(self, matrix, target):
        matrix = np.reshape(matrix, [1, -1]).tolist()[0]
        index = bisect.bisect_left(matrix, target)
        if index < 0 or index >= len(matrix):
            return False
        return matrix[index] == target

90. 子集 II(2021-03-31)
给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。



示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：

输入：nums = [0]
输出：[[],[0]]


提示：

1 <= nums.length <= 10
-10 <= nums[i] <= 10


用python的组合库，这里需要注意
首先要对List进行排序，按照从小到大的顺序排序，这样可以避免产生多余的组合
接下来就是遍历序列，产生组合，重复元素只产生一个组合

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res=[[]]
        nums.sort() # 排序
        for i in range(1, len(nums)+1):
            res.extend(set(itertools.combinations(nums, i)))
        return res

class Solution(object):
    def subsets(self, nums):
        res, path = [], []
        self.dfs(nums, 0, res, path)
        return res

    def dfs(self, nums, index, res, path):
        res.append(copy.deepcopy(path))
        for i in range(index, len(nums)):
            path.append(nums[i])
            self.dfs(nums, i + 1, res, path)
            path.pop()

class Solution(object):
    def subsets(self, nums):
        res = []
        self.dfs(nums, 0, res, [])
        return res

    def dfs(self, nums, index, res, path):
        res.append(path)
        for i in xrange(index, len(nums)):
            self.dfs(nums, i + 1, res, path + [nums[i]])

1006. 笨阶乘 0401
通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。

相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。

例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。

另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。

实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。



示例 1：

输入：4
输出：7
解释：7 = 4 * 3 / 2 + 1
示例 2：

输入：10
输出：12
解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1


提示：

1 <= N <= 10000
-2^31 <= answer <= 2^31 - 1  （答案保证符合 32 位整数。）


class Solution(object):
    def clumsy(self, N):
        op = 0
        stack = [N]
        for i in range(N - 1, 0, -1):
            if op == 0:
                stack.append(stack.pop() * i)
            elif op == 1:
                stack.append(int(stack.pop() / float(i)))
            elif op == 2:
                stack.append(i)
            elif op == 3:
                stack.append(-i)
            op = (op + 1) % 4
        return sum(stack)

# 找规律取巧方法
N = 10

def clumsy(N):
	# 1 <= N <= 4, 手动计算
	if N <= 2:
		return N
	if N <= 4:
		return N + 3
	# 四个为一组，刚好是整组时，结果是：N + 1
	if N % 4 == 0:
		return N + 1
	# 四个为一组，多出三个时，结果是：N - 1
	if N % 4 == 3:
		return N - 1
	# 四个为一组，多出一个或者两个时，结果是：N + 2
	return N + 2

print(clumsy(N))

class Solution(object):
    def clumsy(self, N):
        op = 0
        stack = [N]
        for i in range(N - 1, 0, -1):
            if op == 0:  # 乘
                stack.append(stack.pop() * i)
            elif op == 1:  # 除
                stack.append(int(stack.pop() / float(i)))
            elif op == 2:  # 加
                stack.append(i)
            elif op == 3:  # 减
                stack.append(-i)
            op = (op + 1) % 4
        return sum(stack)

class Solution:
    def clumsy(self, N: int) -> int:
        return N + ((3, 0, 0, 3) if N <= 4 else (1, 2, 2, -1))[N % 4]

class Solution:
    def clumsy(self, N: int) -> int:
        if N<3:return N
        if N==3:return 6
        sum=N*(N-1)//(N-2)+N-3
        N-=4
        while N>=4:
            sum+=-(N*(N-1)//(N-2))+N-3
            N-=4
        return sum-self.clumsy(N)


# 憨憨算法，超时了
# N = 10
num = 10

def clumsy(N):
	# return N + ((3, 0, 0, 3) if N <= 4 else (1, 2, 2, -1))[N & 3]
	symbol = ['*', '/', '+', '-']
	nums = list(range(N, 0, -1))
	# print(symbol, nums)
	# 生成需要计算的公式列表
	s = 0
	result = []
	length = len(nums)
	for n in nums:
		result.append(str(n))
		if nums.index(n) != length - 1:
			result.append(symbol[s])
		# 获取计算符号的索引范围是0~3
		s = s + 1 if s < 3 else 0
		# if s < 3:
		# 	s += 1
		# else:
		# 	s = 0
	print(result)
	# 开始计算
	pre = '+'
	stack = []
	if length == 1:
		print(stack)
		return 1
	for r in result:
		if pre == '*' and r.isdigit():
			stack[-1] = stack[-1] * int(r)
			continue
		if pre == '/' and r.isdigit():
			stack[-1] = int(stack[-1] / int(r))
			continue
		if pre == '-' and r.isdigit():
			stack.append(int(stack.pop() + r))
			stack[-1] = -int(r)
			continue
		if r.isdigit():
			stack.append(int(r))
		elif r == '-':
			stack.append(r)
			pre = r
		else:
			pre = r
	print(stack)
	return sum(stack)

for i in range(1, num + 1):
	print(i, clumsy(i))
# print(num, clumsy(num))

面试题 17.21. 直方图的水量 20210402
给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。



上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6

class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        l, r = [0] * n, [0] * n
        ans = 0
        for i in range(1, len(height)):
            l[i] = max(l[i - 1], height[i - 1])
        for i in range(len(height) - 2, 0, -1):
            r[i] = max(r[i + 1], height[i + 1])
        for i in range(len(height)):
            ans += max(0, min(l[i], r[i]) - height[i])
        return ans

class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0

        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans

class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)

        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)

        return ans

# 双指针
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1

        return ans

笔记疑问：
"string".join(iterable)
可迭代对象本身元素就是字符串，返回一个新的字符串
可迭代对象本身必须是字符串
TypeError: sequence item 0: expected str instance, int found

height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

def trap(height):
	if not height:
		return 0
	high, long = max(height), len(height)
	matrix = [['0'] * long for i in range(high)]  # 生成最大的接水槽
	# print(high, long, matrix)
	for i in range(long):
		if height[i] == '0':  # 如果没有拦水块，不填
			continue
		else:
			for j in range(height[i]):  # 如果有拦水块，索引位置向上填
				matrix[j][i] = '1'
	# print(matrix)
	result = 0
	for k in range(high):
		tank = ''.join(matrix[k]).strip('0')
		count = tank.count('0')
		result += count
	return result

print(trap(height))



LCCUP ‘21 力扣杯春季编程大赛 - 个人赛


LCP 28. 采购方案
小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。

注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1

示例 1：

输入：nums = [2,5,3,5], target = 6

输出：1

解释：预算内仅能购买 nums[0] 与 nums[2]。

示例 2：

输入：nums = [2,2,1,9], target = 10

输出：4

解释：符合预算的采购方案如下：
nums[0] + nums[1] = 4
nums[0] + nums[2] = 3
nums[1] + nums[2] = 3
nums[2] + nums[3] = 10

提示：

2 <= nums.length <= 10^5
1 <= nums[i], target <= 10^5

# 爆解超时，哈哈哈
# LCP 28. 采购方案

nums = [2, 5, 3, 5]
target = 6
nums = [2, 2, 1, 9]
target = 10

def purchasePlans(nums, target):
	count = 0
	for index, i in enumerate(nums):
		for j in nums[index + 1:]:
			if i + j <= target:
				count += 1
			print(i, j, count)
	if count <= 1000000007:
		return count % 1000000007
	else:
		return count

print(purchasePlans(nums, target))

# 超时了，
# LCP 28. 采购方案

nums = [2, 2, 1, 9]
target = 10

def purchasePlans(nums, target):
	count, length = 0, len(nums)
	nums.sort()
	print(nums)
	for i, v in enumerate(nums):
		for j in range(length - 1, i, -1):
			# print(v, nums[j])
			if nums[j] <= target - v:
				count += j - i
				# print(i, j, count)
				break
	if count <= 1000000007:
		return count
	else:
		return count % 1000000007

print(purchasePlans(nums, target))



题目已为大家更新至：
https://leetcode-cn.com/problemset/-/



80. 删除有序数组中的重复项 II	20210406 中等
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



说明：

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}


示例 1：

输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
示例 2：

输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。


提示：

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums 已按升序排列


# 80. 删除有序数组中的重复项 II

nums = [1, 1, 1, 2, 2, 3]
nums = [1, 2, 2, 2]
# nums = [0, 0, 1, 1, 1, 1, 2, 3, 3]

def removeDuplicates(nums):
	cache, count = nums[0], 1
	for i in nums[1:]:
		if i == cache:
			count += 1
			if count > 2:
				nums.remove(i)
				count -= 1
		print(cache, i, count, nums)
		if i != cache:
			cache = i
			count = 1
	return len(nums)

print(removeDuplicates(nums))


class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        #index计数, 也是修改索引,从索引1开始修改
        #count记录值出现的次数,不能超过2，从计数为1开始
        index = count = 1
        #遍历nums，从索引1位置开始遍历
        for i in range(1, len(nums)):
            #如果nums[i] == nums[i - 1],则相同值的计数加1
            if nums[i] == nums[i - 1]:
                count += 1
            #不等的话，计数值重置为1
            else:
                count = 1
            #如果count小于等于2，则可以修改index位置的元素：nums[index] = nums[i]
            if count <= 2:
                nums[index] = nums[i]
                #修改位置索引index+1
                index += 1
        #返回修改的索引值，也就是修改后的nums长度
        return index

class Solution(object):
    def removeDuplicates(self, nums):
        # 慢指针 slow，快指针 fast
        slow = 0
        for fast in range(len(nums)):
            if slow < 2 or nums[fast] != nums[slow - 2]:
                nums[slow] = nums[fast]
                slow += 1
        return slow


81. 搜索旋转排序数组 II  20210407
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。

给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。



示例 1：

输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
示例 2：

输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false


提示：

1 <= nums.length <= 5000
-104 <= nums[i] <= 104
题目数据保证 nums 在预先未知的某个下标上进行了旋转
-104 <= target <= 104


进阶：

这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        return True if target in nums else False

class Solution(object):
    def search(self, nums, target):
        if not nums: return -1
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] <= nums[right]:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if target < nums[mid] and target >= nums[left]:
                    right = mid - 1
                else:
                    left = mid + 1
        return -1



C++ 参考手册
https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5

javaguide
https://snailclimb.gitee.io/javaguide/#/


153. 寻找旋转排序数组中的最小值  20210408
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。



示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。


提示：

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums 中的所有整数 互不相同
nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

# 投机做法
class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)

# 憨批做法
class Solution:
    def findMin(self, nums: List[int]) -> int:
        cache = nums[0]
        for i in nums:
            if i < cache:
                cache = i
        return cache


class Solution:
    def findMin(self, nums: List[int]) -> int:
        n = len(nums)
        l, r = 0, n - 1
        while l < r:
            mid = (l + r + 1) >> 1
            if(nums[mid] >= nums[0]):
                l = mid
            else:
                r = mid - 1
        return nums[r + 1] if r + 1 < n else nums[0]

class Solution(object):
    def findMin(self, nums):
        if len(nums) == 1: return nums[0]
        left, right = 0, len(nums) - 1
        mid = left
        while nums[left] >= nums[right]:
            if left + 1 == right:
                mid = right
                break
            mid = (left + right) // 2
            if nums[mid] >= nums[left]:
                left = mid
            elif nums[mid] <= nums[right]:
                right = mid
        return nums[mid]

# 寻找旋转排序数组中的最小值

nums = [4, 5, 6, 7, 0, 1, 2]
# nums = [11, 13, 15, 17]

def findMin(nums):
	if len(nums) == 1: return nums[0]
	left, right = 0, len(nums) - 1
	mid = left
	while nums[left] >= nums[right]:
		if left + 1 == right:
			mid = right
			break
		mid = (left + right) // 2
		if nums[mid] >= nums[left]:
			left = mid
		# elif nums[mid] <= nums[left]:
		else:
			right = mid
	return nums[mid]

print(findMin(nums))

class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            #nums[l] <= nums[r]说明当前只有一个元素或者没有旋转，直接返回nums[l]即是最小值
            if nums[l] <= nums[r]:
                return nums[l]
            else:
                mid = (l + r) >> 1
                #左边有序,最小值在右边,这里有=号是为了处理[2,1]这种情况
                if nums[l] <= nums[mid]:
                    l = mid + 1
                #右边有序，最小值应该有可能在左边，注意：应该包括nums[mid]，因为该最小值有可能就是nums[mid]
                elif nums[r] > nums[mid]:
                    r = mid


154. 寻找旋转排序数组中的最小值 II  20210409
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。



示例 1：

输入：nums = [1,3,5]
输出：1
示例 2：

输入：nums = [2,2,2,0,1]
输出：0


提示：

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转


进阶：

这道题是 寻找旋转排序数组中的最小值 的延伸题目。
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

class Solution:
    def findMin(self, nums: List[int]) -> int:
        return min(nums)

nums = [2, 2, 2, 2, 0, 1]

def findMin(nums):
	left, right = 0, len(nums) - 1
	while left < right:
		# mid = (left + right) // 2
		mid = left + (right - left) // 2
		# 如果mid值比最右边的值小，说明最小值在mid的前(左)面
		if nums[mid] < nums[right]:
			right = mid
		# 如果mid值比最右边的值大，说明最小值在mid的后(右)面
		elif nums[mid] > nums[right]:
			left = mid + 1
		# 如果mid值比最右边的值相等，缩短右边的范围
		else:
			right -= 1
	return nums[left]

print(findMin(nums))


class Solution:
    def findMin(self, nums: List[int]) -> int:
        i = 0
        nums.append(nums[0]-1)
        while nums[i] <= nums[i+1]:
            i += 1
        if i == len(nums) - 2:
            return nums[0]
        return nums[i+1]

7. 整数反转
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
示例 4：

输入：x = 0
输出：0


提示：

-231 <= x <= 231 - 1

class Solution:
    def reverse(self, x: int) -> int:
        if str(x).isdigit():
            n = [i for i in str(x)]
            n.reverse()
        else:
            n = [i for i in str(-x)]
            n.append('-')
            n.reverse()
        X = int(''.join(n))
        if -2 ** 31 <= X <= 2 ** 31 -1:
            return X
        else:
            return 0

class Solution:
    def reverse(self, x: int) -> int:
        n = []
        for i in str(x)[::-1]:
            if i == "-":
                n.insert(0, i)
            else:
                n.append(i)
        X = int(''.join(n))
        if -2 ** 31 <= X <= 2 ** 31 -1:
            return X
        else:
            return 0

def reverse(x: int) -> int:
    result = int(str(x).lstrip('-')[::-1])
    if x < 0:
        return -result if -2 ** 31 <= -result else 0
    return result if result <= 2 ** 31 + 1 else 0


9. 回文数
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。



示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
示例 4：

输入：x = -101
输出：false


提示：

-231 <= x <= 231 - 1


进阶：你能不将整数转为字符串来解决这个问题吗？

class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x >= 0:  # 只考虑大于等于0的情况，小于零直接返回False
            if x == int(str(x)[::-1]):  # 只考虑相等的情况，不等直接返回False
                return True
        return False  #

263. 丑数
给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。



示例 1：

输入：n = 6
输出：true
解释：6 = 2 × 3
示例 2：

输入：n = 8
输出：true
解释：8 = 2 × 2 × 2
示例 3：

输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
示例 4：

输入：n = 1
输出：true
解释：1 通常被视为丑数。


提示：

-231 <= n <= 231 - 1

class Solution:
    def isUgly(self, n: int) -> bool:
        0和负数都不是丑数
        if n <= 0:
            return False
        # 把n对2、3、5整除
        while n % 2 == 0:
            n //= 2
        while n % 3 == 0:
            n //= 3
        while n % 5 == 0:
            n //= 5
        # 最后是否仅剩下1
		return n == 1

class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False

        factors = [2, 3, 5]
        for factor in factors:
            while n % factor == 0:
                # print(n)
                n //= factor

        return n == 1

class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        while n > 1:
            # print(n)
            if n % 2 == 0:
                n //= 2
            elif n % 3 == 0:
                n //= 3
            elif n % 5 == 0:
                n //= 5
            else:
                return False
        return n == 1

力扣杯春季编程大赛 战队赛题目 20210410

1. 蓄水
通过的用户数567
尝试过的用户数2130
用户总通过次数572
用户总提交次数7265
题目难度Easy
给定 N 个无限容量且初始均空的水缸，每个水缸配有一个水桶用来打水，第 i 个水缸配备的水桶容量记作 bucket[i]。小扣有以下两种操作：

升级水桶：选择任意一个水桶，使其容量增加为 bucket[i]+1
蓄水：将全部水桶接满水，倒入各自对应的水缸
每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。

注意：实际蓄水量 达到或超过 最低蓄水量，即完成蓄水要求。

示例 1：

输入：bucket = [1,3], vat = [6,8]

输出：4

解释：
第 1 次操作升级 bucket[0]；
第 2 ~ 4 次操作均选择蓄水，即可完成蓄水要求。
vat1.gif

示例 2：

输入：bucket = [9,0,1], vat = [0,2,2]

输出：3

解释：
第 1 次操作选择升级 bucket[1]
第 2~3 次操作选择蓄水，即可完成蓄水要求。

提示：

1 <= bucket.length == vat.length <= 100
0 <= bucket[i], vat[i] <= 10^4

2. 二叉树染色
通过的用户数364
尝试过的用户数597
用户总通过次数365
用户总提交次数1214
题目难度Medium
小扣有一个根结点为 root 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色，模型的每个结点有一个 val 价值。小扣出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 k 个，求所有染成蓝色的结点价值总和最大是多少？

示例 1：

输入：root = [5,2,3,4], k = 2

输出：12

解释：结点 5、3、4 染成蓝色，获得最大的价值 5+3+4=12
image.png

示例 2：

输入：root = [4,1,3,9,null,null,2], k = 2

输出：16

解释：结点 4、3、9 染成蓝色，获得最大的价值 4+3+9=16
image.png

提示：

1 <= k <= 10
1 <= val <= 10000
1 <= 结点数量 <= 10000

3. 电动车游城市
通过的用户数159
尝试过的用户数283
用户总通过次数160
用户总提交次数556
题目难度Hard
小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间。小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1。他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，表示城市 A、B 间存在双向通路。初始状态，电动车电量为 0。每个城市都设有充电桩，charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end。

示例 1：

输入：paths = [[1,3,3],[3,2,1],[2,1,3],[0,1,4],[3,0,5]], cnt = 6, start = 1, end = 0, charge = [2,10,4,1]

输出：43

解释：最佳路线为：1->3->0。
在城市 1 仅充 3 单位电至城市 3，然后在城市 3 充 5 单位电，行驶至城市 5。
充电用时共 3*10 + 5*1= 35
行驶用时 3 + 5 = 8，此时总用时最短 43。
image.png

示例 2：

输入：paths = [[0,4,2],[4,3,5],[3,0,5],[0,1,5],[3,2,4],[1,2,8]], cnt = 8, start = 0, end = 2, charge = [4,1,1,3,2]

输出：38

解释：最佳路线为：0->4->3->2。
城市 0 充电 2 单位，行驶至城市 4 充电 8 单位，行驶至城市 3 充电 1 单位，最终行驶至城市 2。
充电用时 4*2+2*8+3*1 = 27
行驶用时 2+5+4 = 11，总用时最短 38。

提示：

1 <= paths.length <= 200
paths[i].length == 3
2 <= charge.length == n <= 100
0 <= path[i][0],path[i][1],start,end < n
1 <= cnt <= 100
1 <= path[i][2] <= cnt
1 <= charge[i] <= 100
题目保证所有城市相互可以到达
收起
本场比赛距离结束剩余 0 小时 54 分 15 秒
我的战队	ccctts
开始比赛

当前得分	0/41
序号	题目	状态	错误提交	得分	贡献自
1
蓄水
未通过
2	0/2
2
二叉树染色
未答题
0	0/4
3
电动车游城市
未答题
0	0/6
4
最多牌组数
未答题
0	0/8
5
最小矩形面积
未答题
0	0/9
6
守卫城堡
未通过
1	0/12
总错误提交	3
重要提示

战队赛于 2021-04-10 15:00 开赛，共计 6 题，比赛时长 180 分钟。

题目依据难易度有不同分值，得分越高排名越高；在得分相同的情况下，完赛用时越少则排名越高。

每队成员不超过 3 人，按团队总得分进行排名；比赛期间每题可多人同时作答，每题将选取首次显示“通过”的得分，计入比赛总得分。

比赛中每题首次显示“通过”前，队内每位成员每提交一次错误解答，完赛用时将增加 5 分钟，请队内注意交流配合，避免最终完赛用时过长。

为了防止作弊行为，选手在提交错误解答后，会告知该错误的类型，不会告知具体的错误用例。

本次大赛支持使用以下主流编程语言进行解答：C++、Java、Python、C、C#、JavaScript、Ruby、Bash、Swift、Go、Python3、Scala、Kotlin、Rust、PHP、TypeScript、Racket；请注意使用 Python/Python3 的参赛者不能使用 numpy/scipy 等科学计算库。

参赛用户须对报名时所填写的参赛信息的真实性、合法性、有效性承担全部责任。所有解答提交都会自动经过力扣严格的智能作弊侦测系统，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们坚持以 零容忍 的态度维护竞赛的公平、公正。


4. 最多牌组数
通过的用户数62
尝试过的用户数319
用户总通过次数62
用户总提交次数744
题目难度Hard
麻将的游戏规则中，共有两种方式凑成「一组牌」：

顺子：三张牌面数字连续的麻将，例如 [4,5,6]
刻子：三张牌面数字相同的麻将，例如 [10,10,10]
给定若干数字作为麻将牌的数值（记作一维数组 tiles），请返回所给 tiles 最多可组成的牌组数。

注意：凑成牌组时，每张牌仅能使用一次。

示例 1：

输入：tiles = [2,2,2,3,4]

输出：1

解释：最多可以组合出 [2,2,2] 或者 [2,3,4] 其中一组牌。

示例 2：

输入：tiles = [2,2,2,3,4,1,3]

输出：2

解释：最多可以组合出 [1,2,3] 与 [2,3,4] 两组牌。

提示：

1 <= tiles.length <= 10^5
1 <= tiles[i] <= 10^9

5.
LCP 37. 最小矩形面积
二维平面上有 NN 条直线，形式为 y = kx + b，其中 k、b为整数 且 k > 0。所有直线以 [k,b] 的形式存于二维数组 lines 中，不存在重合的两条直线。两两直线之间可能存在一个交点，最多会有 C_N^2C
N
2
​
  个交点。我们用一个平行于坐标轴的矩形覆盖所有的交点，请问这个矩形最小面积是多少。若直线之间无交点、仅有一个交点或所有交点均在同一条平行坐标轴的直线上，则返回0。

注意：返回结果是浮点数，与标准答案 绝对误差或相对误差 在 10^-4 以内的结果都被视为正确结果

示例 1：

输入：lines = [[2,3],[3,0],[4,1]]

输出：48.00000

解释：三条直线的三个交点为 (3, 9) (1, 5) 和 (-1, -3)。最小覆盖矩形左下角为 (-1, -3) 右上角为 (3,9)，面积为 48

示例 2：

输入：lines = [[1,1],[2,3]]

输出：0.00000

解释：仅有一个交点 (-2，-1）

限制：

1 <= lines.length <= 10^5 且 lines[i].length == 2
1 <= lines[0] <= 10000
-10000 <= lines[1] <= 10000
与标准答案绝对误差或相对误差在 10^-4 以内的结果都被视为正确结果
通过次数100提交次数1,398

6. 守卫城堡
题目难度Hard
城堡守卫游戏的胜利条件为使恶魔无法从出生点到达城堡。游戏地图可视作 2*N 的方格图，记作字符串数组 grid，其中：

"." 表示恶魔可随意通行的平地；
"#" 表示恶魔不可通过的障碍物，玩家可通过在 平地 上设置障碍物，即将 "." 变为 "#" 以阻挡恶魔前进；
"S" 表示恶魔出生点，将有大量的恶魔该点生成，恶魔可向上/向下/向左/向右移动，且无法移动至地图外；
"P" 表示瞬移点，移动到 "P" 点的恶魔可被传送至任意一个 "P" 点，也可选择不传送；
"C" 表示城堡。
然而在游戏中用于建造障碍物的金钱是有限的，请返回玩家最少需要放置几个障碍物才能获得胜利。若无论怎样放置障碍物均无法获胜，请返回 -1。

注意：

地图上可能有一个或多个出生点
地图上有且只有一个城堡
示例 1

输入：grid = ["S.C.P#P.", ".....#.S"]

输出：3

解释：至少需要放置三个障碍物
image.png

示例 2：

输入：grid = ["SP#P..P#PC#.S", "..#P..P####.#"]

输出：-1

解释：无论怎样修筑障碍物，均无法阻挡最左侧出生的恶魔到达城堡位置
image.png

示例 3：

输入：grid = ["SP#.C.#PS", "P.#...#.P"]

输出：0

解释：无需放置障碍物即可获得胜利
image.png

示例 4：

输入：grid = ["CP.#.P.", "...S..S"]

输出：4

解释：至少需要放置 4 个障碍物，示意图为放置方法之一
image.png

提示：

grid.length == 2
2 <= grid[0].length == grid[1].length <= 10^4
grid[i][j] 仅包含字符 "."、"#"、"C"、"P"、"S"


grid = ["S.C.P#P.", ".....#.S"]
grid = ["SP#P..P#PC#.S", "..#P..P####.#"]

def guardCastle(grid):
	for i in range(2):
		if grid[i].find('C') != -1:
			index1, index2 = i, grid[i].index('C')
	# print(index1, index2)
	# index1 = 0, index1 - 1 = -1; index1 = 1, index1 - 1 = 0
	if grid[index1][index2 - 1] == 'P' or grid[index1][index2 + 1] == 'P' or grid[index1 - 1][index2] == 'P':
		return -1
	if grid[index1][index2 - 1] == '.' and grid[index1][index2 + 1] == '.' and grid[index1 - 1][index2] == '.':
		return 3


print(guardCastle(grid))


179. 最大数 20210412
给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。



示例 1：

输入：nums = [10,2]
输出："210"
示例 2：

输入：nums = [3,30,34,5,9]
输出："9534330"
示例 3：

输入：nums = [1]
输出："1"
示例 4：

输入：nums = [10]
输出："10"


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 109

def largestNumber(self, nums):
        from functools import cmp_to_key
        key = cmp_to_key(lambda x,y: int(y+x)-int(x+y))
        res = ''.join(sorted(map(str, nums), key=key)).lstrip('0')
        return res or '0'



783. 二叉搜索树节点最小距离
给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。

注意：本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同



示例 1：


输入：root = [4,2,6,1,3]
输出：1
示例 2：


输入：root = [1,0,48,null,null,12,49]
输出：1


提示：

树中节点数目在范围 [2, 100] 内
0 <= Node.val <= 105


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        ############ 最笨的办法 开个空间（数组）把数字都存下来
        vals = []
        ########## 中序遍历 ###########
        def dfs_LNR(rt: TreeNode) -> None:
            if rt == None:  return
            dfs_LNR(rt.left)
            vals.append(rt.val)
            dfs_LNR(rt.right)

        dfs_LNR(root)
        res = float('inf')
        n = len(vals)
        for i in range(1, n):
            res = min(res, vals[i] - vals[i-1])
        return res

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        self.res = float('inf')
        self.pre_val = -1
        ###### 中序遍历 ########
        def dfs_LNR(rt: TreeNode) -> None:
            if rt == None:  return
            dfs_LNR(rt.left)

            if self.pre_val != -1:
                self.res = min(self.res, rt.val - self.pre_val)
            self.pre_val = rt.val

            dfs_LNR(rt.right)

        dfs_LNR(root)
        return self.res

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def minDiffInBST(self, root):
        self.vals = []
        self.inOrder(root)
        return min([self.vals[i + 1] - self.vals[i] for i in xrange(len(self.vals) - 1)])

    def inOrder(self, root):
        if not root:
            return
        self.inOrder(root.left)
        self.vals.append(root.val)
        self.inOrder(root.right)

208. 实现 Trie (前缀树) 20210414
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。


示例：

输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True


提示：

1 <= word.length, prefix.length <= 2000
word 和 prefix 仅由小写英文字母组成
insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次
通过次数84,155提交次数119,764

class Node(object):
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie(object):

    def __init__(self):
        self.root = Node()

    def insert(self, word):
        current = self.root
        for w in word:
            current = current.children[w]
        current.isword = True

    def search(self, word):
        current = self.root
        for w in word:
            current = current.children.get(w)
            if current == None:
                return False
        return current.isword

    def startsWith(self, prefix):
        current = self.root
        for w in prefix:
            current = current.children.get(w)
            if current == None:
                return False
        return True


class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def searchPrefix(self, prefix: str) -> "Trie":
        node = self
        for ch in prefix:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                return None
            node = node.children[ch]
        return node

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.searchPrefix(word)
        return node is not None and node.isEnd

    def startsWith(self, prefix: str) -> bool:
        return self.searchPrefix(prefix) is not None


class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self._children = [None] * 26
        self._is_ending_char = False


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        root = self
        for index, char in map(lambda x: (ord(x) - ord("a"), x), word):
            if not root._children[index]:
                root._children[index] = Trie()
            root = root._children[index]
        root._is_ending_char = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        root = self
        for index in map(lambda x: ord(x) - ord("a"), word):
            if not root._children[index]:
                return False
            root = root._children[index]
        return root._is_ending_char


    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        root = self
        for index in map(lambda x: ord(x) - ord("a"), prefix):
            if not root._children[index]:
                return False
            root = root._children[index]
        return True


# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)


class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.dic = {}


    def insert(self, word: str) -> None:
        """
        Inserts a word into the trie.
        """
        t = self.dic
        for w in word:
            if w not in t:
                t[w] = {}
            t = t[w]
        t['end'] = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the trie.
        """
        t = self.dic
        for w in word:
            if w not in t:
                return False
            t = t[w]
        return 'end' in t


    def startsWith(self, prefix: str) -> bool:
        """
        Returns if there is any word in the trie that starts with the given prefix.
        """
        t = self.dic
        for w in prefix:
            if w not in t:
                return False
            t = t[w]
        return True

213. 打家劫舍 II 20210415
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。



示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：

输入：nums = [0]
输出：0


提示：

1 <= nums.length <= 100
0 <= nums[i] <= 1000


class Solution:
    def rob(self, nums: List[int]) -> int:
        def robRange(start: int, end: int) -> int:
            first = nums[start]
            second = max(nums[start], nums[start + 1])
            for i in range(start + 2, end + 1):
                first, second = second, max(first + nums[i], second)
            return second

        length = len(nums)
        if length == 1:
            return nums[0]
        elif length == 2:
            return max(nums[0], nums[1])
        else:
            return max(robRange(0, length - 2), robRange(1, length - 1))

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) <= 3:
            return max(nums)

        def do_dp(nums):
            dp = [0] * len(nums)
            dp[0] = nums[0]
            dp[1] = max(nums[0], nums[1])
            for i in range(2, len(nums)):
                dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
            return dp[-1]

        return max(do_dp(nums[:-1]), do_dp(nums[1:]))

198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。


class Solution:
    def rob(self, nums: List[int]) -> int:
        last = 0
        now = 0
        for i in nums:
            last, now = now, max(last + i, now)
        return now


class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        size = len(nums)
        if size == 1:
            return nums[0]
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]


class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]

        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

        return dp[size - 1]

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]

        first, second = nums[0], max(nums[0], nums[1])
        for i in range(2, size):
            first, second = second, max(first + nums[i], second)

        return second


剑指 Offer 10- II. 青蛙跳台阶问题
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

输入：n = 2
输出：2
示例 2：

输入：n = 7
输出：21
示例 3：

输入：n = 0
输出：1
提示：

0 <= n <= 100

### 逆向思维，如果 n = 3，因为青蛙可以跳1阶，也可以跳2阶，即：
可以从2级台阶跳1阶到3级台阶，也可以从第1级台阶跳2阶到第3级台阶，
也就是说跳3级台阶的跳法等于跳2级台阶的跳法加上跳1级台阶的跳法
即：dp(n) = dp(n - 2) + dp(n - 1)

### 可以转成斐波那契数列


# 动态规划
class Solution:
    def numWays(self, n: int) -> int:
        if n <= 1:
            return 1
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 2] + dp[i - 1]
        return dp[-1] % 1000000007

# 滚动数组
class Solution:
    def numWays(self, n: int) -> int:
        if n <= 1:
            return 1
        first, second = 1, 1
        for i in range(2, n + 1):
            first, second = second, first + second
        return second % 1000000007

class Solution:
    def numWays(self, n: int) -> int:
        a, b = 1, 1
        for _ in range(n - 1):
            a, b = b, a + b
        return b % 1000000007


剑指 Offer 10- I. 斐波那契数列
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。



示例 1：

输入：n = 2
输出：1
示例 2：

输入：n = 5
输出：5


提示：

0 <= n <= 100

class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        first, second = 0, 1
        for i in range(2, n + 1):
            first, second = second, first + second
        return second % 1000000007

967. 连续差相同的数字
返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。

请注意，除了 数字 0 本身之外，答案中的每个数字都 不能 有前导零。例如，01 有一个前导零，所以是无效的；但 0 是有效的。

你可以按 任何顺序 返回答案。



示例 1：

输入：n = 3, k = 7
输出：[181,292,707,818,929]
解释：注意，070 不是一个有效的数字，因为它有前导零。
示例 2：

输入：n = 2, k = 1
输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
示例 3：

输入：n = 2, k = 0
输出：[11,22,33,44,55,66,77,88,99]
示例 4：

输入：n = 2, k = 2
输出：[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]


提示：

2 <= n <= 9
0 <= k <= 9



class Solution(object):
    def numsSameConsecDiff(self, N, K):
        ans = {x for x in range(1, 10)}
        for _ in xrange(N-1):
            ans2 = set()
            for x in ans:
                d = x % 10
                if d - K >= 0:
                    ans2.add(10*x + d-K)
                if d + K <= 9:
                    ans2.add(10*x + d+K)
            ans = ans2

        if N == 1:
            ans.add(0)

        return list(ans)




 建议
import x（当x是包或模块）
from x import y （当x是包前缀，y是不带前缀的模块名）
from x import  y as z （当有重复模块名y或y过长不利于引用的时候）
import y as z （仅在非常通用的简写的时候使用例如import numpy as np）


87. 扰乱字符串 20210416
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。



示例 1：

输入：s1 = "great", s2 = "rgeat"
输出：true
解释：s1 上可能发生的一种情形是：
"great" --> "gr/eat" // 在一个随机下标处分割得到两个子字符串
"gr/eat" --> "gr/eat" // 随机决定：「保持这两个子字符串的顺序不变」
"gr/eat" --> "g/r / e/at" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割
"g/r / e/at" --> "r/g / e/at" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」
"r/g / e/at" --> "r/g / e/ a/t" // 继续递归执行此算法，将 "at" 分割得到 "a/t"
"r/g / e/ a/t" --> "r/g / e/ a/t" // 随机决定：「保持这两个子字符串的顺序不变」
算法终止，结果字符串和 s2 相同，都是 "rgeat"
这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true
示例 2：

输入：s1 = "abcde", s2 = "caebd"
输出：false
示例 3：

输入：s1 = "a", s2 = "a"
输出：true


提示：

s1.length == s2.length
1 <= s1.length <= 30
s1 和 s2 由小写英文字母组成

class Solution:
    @functools.lru_cache(None)
    def isScramble(self, s1: str, s2: str) -> bool:
        N = len(s1)
        if N == 0: return True
        if N == 1: return s1 == s2
        if sorted(s1) != sorted(s2):
            return False
        for i in range(1, N):
            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
                return True
            elif self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):
                return True
        return False


class Solution:
    @functools.lru_cache(None)
    def isScramble(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        if sorted(s1) != sorted(s2):
            return False
        for i in range(1, len(s1)):
            if self.isScramble(s1[:i],s2[:i]) and self.isScramble(s1[i:],s2[i:]):
                return True
            if self.isScramble(s1[:i],s2[-i:]) and self.isScramble(s1[i:],s2[:-i]):
                return True
        return False

27. 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}


示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
示例 2：

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。


提示：

0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        for i in range(len(nums)):
            if val in nums:
                nums.remove(val)
        return len(nums)

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        for i in nums[:]:
            if i == val:
                nums.remove(i)
        return len(nums)

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        a = 0
        b = 0

        while a < len(nums):
            if nums[a] != val:
                nums[b] = nums[a]
                b += 1
            a += 1

        return b

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if len(nums) == 0:
            return 0
        slow = 0
        for quick in range(0, len(nums)):
            if nums[quick] != val:
                nums[slow] = nums[quick]
                slow += 1
        return slow


28. 实现 strStr() 20210420
实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。



说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。



示例 1：

输入：haystack = "hello", needle = "ll"
输出：2
示例 2：

输入：haystack = "aaaaa", needle = "bba"
输出：-1
示例 3：

输入：haystack = "", needle = ""
输出：0


提示：

0 <= haystack.length, needle.length <= 5 * 104
haystack 和 needle 仅由小写英文字符组成



class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not haystack and not needle:
            return 0
        if not haystack:
            return -1
        if not needle or haystack == needle:
            return 0
        return len(haystack.split(needle)[0]) if needle in haystack else -1

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        return haystack.find(needle)


枚举法：

haystack = "hello"
needle = "ll"


def strStr(haystack, needle):
	n, m = len(haystack), len(needle)
	for i in range(n - m + 1):
		j, k = i, 0
		while k < m and haystack[j] == needle[k]:
			j += 1
			k += 1
		if k == m:
			return i
	return -1

print(strStr(haystack, needle))


91. 解码方法 20210421
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。



示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
示例 4：

输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。


提示：

1 <= s.length <= 100
s 只包含数字，并且可能包含前导零。


class Solution:
    def numDecodings(self, s: str) -> int:
        legalstr = set(str(i) for i in range(1, 27))
        self.ans = 0
        def dfs(s):
            if len(s)==0:
                self.ans += 1
                return
            # 对于任何一个字符串，我们每次可以读取一到两个
            if s[0] in legalstr:
                dfs(s[1 : ])
            if len(s)>1 and s[ : 2] in legalstr:
                dfs(s[2 : ])
            return
        dfs(s)
        return self.ans

class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        s = ' ' + s
        f = [0] * (n + 1)
        f[0] = 1
        for i in range(1,n + 1):
            a = ord(s[i]) - ord('0')
            b = ( ord(s[i - 1]) - ord('0') ) * 10 + ord(s[i]) - ord('0')
            if 1 <= a <= 9:
                f[i] = f[i - 1]
            if 10 <= b <= 26:
                f[i] += f[i - 2]
        return f[n]

class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        s = ' ' + s
        f = [0] * 3
        f[0] = 1
        for i in range(1,n + 1):
            f[i % 3] = 0
            a = ord(s[i]) - ord('0')
            b = ( ord(s[i - 1]) - ord('0') ) * 10 + ord(s[i]) - ord('0')
            if 1 <= a <= 9:
                f[i % 3] = f[(i - 1) % 3]
            if 10 <= b <= 26:
                f[i % 3] += f[(i - 2) % 3]
        return f[n % 3]


363. 矩形区域不超过 K 的最大数值和 20210422
给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。

题目数据保证总会存在一个数值和不超过 k 的矩形区域。



示例 1：


输入：matrix = [[1,0,1],[0,-2,3]], k = 2
输出：2
解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
示例 2：

输入：matrix = [[2,2,-1]], k = 3
输出：3


提示：

m == matrix.length
n == matrix[i].length
1 <= m, n <= 100
-100 <= matrix[i][j] <= 100
-105 <= k <= 105


进阶：如果行数远大于列数，该如何设计解决方案？

from sortedcontainers import SortedList
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        Row, Col = len(matrix), len(matrix[0])
        res = float('-inf')
        for L in range(Col):        #L为左边界
            row_sum = [0 for _ in range(Row)]   #L为左边界R为右边界，各行的和
            for R in range(L, Col):
                for r in range(Row):
                    row_sum[r] += matrix[r][R]

                presum = SortedList([0])                    #前缀和
                cur_sum = 0                     #当前的前缀和
                for rowsum in row_sum:
                    cur_sum += rowsum
                    idx = presum.bisect_left(cur_sum - k)   #第一个大于等于cur_sum - k的值的index
                    if idx < len(presum):
                        res = max(res, cur_sum - presum[idx])
                    presum.add(cur_sum)
        return res

作者：Hanxin_Hanxin
链接：https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/c-python3-liang-ge-shu-mu-ban-jia-zhu-qu-o71z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        Row, Col = len(matrix), len(matrix[0])
        res = float('-inf')
        for L in range(Col):        #L为左边界
            row_sum = [0 for _ in range(Row)]   #L为左边界R为右边界，各行的和
            for R in range(L, Col):
                for r in range(Row):
                    row_sum[r] += matrix[r][R]

                presum = [0]                    #前缀和
                cur_sum = 0                     #当前的前缀和
                for rowsum in row_sum:
                    cur_sum += rowsum
                    idx = bisect.bisect_left(presum, cur_sum - k)   #第一个大于等于cur_sum - k的值的index
                    if idx < len(presum):
                        res = max(res, cur_sum - presum[idx])
                    bisect.insort(presum, cur_sum)
        return res

作者：Hanxin_Hanxin
链接：https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/c-python3-liang-ge-shu-mu-ban-jia-zhu-qu-o71z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


from sortedcontainers import SortedList
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        Row, Col = len(matrix), len(matrix[0])
        res = float('-inf')
        for U in range(Row):        #U为上边界
            col_sum = [0 for _ in range(Col)]   #U为上边界D为下边界，各列的和
            for D in range(U, Row):
                for c in range(Col):
                    col_sum[c] += matrix[D][c]

                presum = SortedList([0])                    #前缀和
                cur_sum = 0                     #当前的前缀和
                for colsum in col_sum:
                    cur_sum += colsum
                    idx = presum.bisect_left(cur_sum - k)   #第一个大于等于cur_sum - k的值的index
                    if idx < len(presum):
                        res = max(res, cur_sum - presum[idx])
                    presum.add(cur_sum)
        return res

作者：Hanxin_Hanxin
链接：https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/c-python3-liang-ge-shu-mu-ban-jia-zhu-qu-o71z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



368. 最大整除子集 20210423
给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可。



示例 1：

输入：nums = [1,2,3]
输出：[1,2]
解释：[1,3] 也会被视为正确答案。
示例 2：

输入：nums = [1,2,4,8]
输出：[1,2,4,8]


提示：

1 <= nums.length <= 1000
1 <= nums[i] <= 2 * 109
nums 中的所有整数 互不相同
通过次数15,239提交次数36,622


class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        f = [[x] for x in nums] # answer at nums[i]
        for j in range(len(nums)):
            for i in range(j):
                if nums[j]%nums[i]==0 and len(f[i])+1 > len(f[j]):
                    f[j] = f[i] + [nums[j]]
        return max(f, key=len)

class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = dict()
        for num in nums:
            try:
                dp[num] = max([v for k,v in dp.items() if num % k == 0],key=len) + [num]
            except:
                dp[num] = [num]
        return max(dp.values(),key=len)

作者：qubenhao
链接：https://leetcode-cn.com/problems/largest-divisible-subset/solution/python-zi-dian-dp-by-qubenhao-11tp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        dp = dict()
        ans = []
        for num in nums:
            max_list = []
            for key, val in dp.items():
                if num % key == 0 and len(val) > len(max_list):
                    max_list = val
            if not max_list:
                dp[num] = [num]
            else:
                dp[num] = max_list + [num]
            if len(dp[num]) > len(ans):
                ans = dp[num]
        return ans

作者：qubenhao
链接：https://leetcode-cn.com/problems/largest-divisible-subset/solution/python-zi-dian-dp-by-qubenhao-11tp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

897. 递增顺序搜索树 20210425
给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。



示例 1：


输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
示例 2：


输入：root = [5,1,7]
输出：[1,null,5,null,7]


提示：

树中节点数的取值范围是 [1, 100]
0 <= Node.val <= 1000

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        data = []
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            data.append(root.val)
            dfs(root.right)
        dfs(root)
        temp_root = TreeNode()
        new_root = temp_root
        for c in data:
            temp = TreeNode(val = c)
            temp_root.right = temp
            temp_root = temp
        return new_root.right

作者：sunyingjian
链接：https://leetcode-cn.com/problems/increasing-order-search-tree/solution/python-zhong-xu-bian-li-40msshi-xian-dai-7fyi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        cur = root
        stack = []
        while cur is not None:
            stack.append(cur)
            cur = cur.left
        root = stack[-1]
        while len(stack):
            node = stack.pop()
            if node.right is not None:
                cur = node.right
                while cur is not None:
                    stack.append(cur)
                    cur = cur.left
            if len(stack):
                node.right = stack[-1]
                stack[-1].left = None
        return root

作者：baka-2
链接：https://leetcode-cn.com/problems/increasing-order-search-tree/solution/python-fei-di-gui-by-baka-2-8jww/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        def helper(node):
            if node:
                helper(node.left)
                node.left = None
                self.cur.right = node
                self.cur = node
                helper(node.right)
        ans = self.cur = TreeNode()
        helper(root)
        return ans.right

作者：juicern
链接：https://leetcode-cn.com/problems/increasing-order-search-tree/solution/duo-chong-yu-yan-bian-bian-li-bian-xiu-g-a2l4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





第 238 场周赛

5738. K 进制表示下的各位数字总和 显示英文描述
题目难度Easy
给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。

转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。



示例 1：

输入：n = 34, k = 6
输出：9
解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。
示例 2：

输入：n = 10, k = 10
输出：1
解释：n 本身就是 10 进制。 1 + 0 = 1 。


提示：

1 <= n <= 100
2 <= k <= 10


 class Solution:
    def sumBase(self, n: int, k: int) -> int:
        result = []
        while n >= k:
            m = n % k
            n //= k
            result.append(m)
        result.append(n)
        return sum(result)

class Solution:
    def sumBase(self, n: int, k: int) -> int:
        result = 0
        while n >= k:
            m = n % k
            n //= k
            result += m
        result += n
        return result

5739. 最高频元素的频数 显示英文描述
通过的用户数161
尝试过的用户数452
用户总通过次数161
用户总提交次数679
题目难度Medium
元素的 频数 是该元素在一个数组中出现的次数。

给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。

执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。



示例 1：

输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
示例 2：

输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
示例 3：

输入：nums = [3,9,6], k = 2
输出：1


提示：

1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 105




5740. 所有元音按顺序排布的最长子字符串 显示英文描述
通过的用户数241
尝试过的用户数353
用户总通过次数242
用户总提交次数559
题目难度Medium
当一个字符串满足如下条件时，我们称它是 美丽的 ：

所有 5 个英文元音字母（'a' ，'e' ，'i' ，'o' ，'u'）都必须 至少 出现一次。
这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 'a' 都在 'e' 前面，所有的 'e' 都在 'i' 前面，以此类推）
比方说，字符串 "aeiou" 和 "aaaaaaeiiiioou" 都是 美丽的 ，但是 "uaeio" ，"aeoiu" 和 "aaaeeeooo" 不是美丽的 。

给你一个只包含英文元音字母的字符串 word ，请你返回 word 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。

子字符串 是字符串中一个连续的字符序列。



示例 1：

输入：word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
输出：13
解释：最长子字符串是 "aaaaeiiiiouuu" ，长度为 13 。
示例 2：

输入：word = "aeeeiiiioooauuuaeiou"
输出：5
解释：最长子字符串是 "aeiou" ，长度为 5 。
示例 3：

输入：word = "a"
输出：0
解释：没有美丽子字符串，所以返回 0 。


提示：

1 <= word.length <= 5 * 105
word 只包含字符 'a'，'e'，'i'，'o' 和 'u' 。


class Solution:
    def longestBeautifulSubstring(self, word: str) -> int:
        stack = ['a']
        result = 0
        for w in word:
            if w == 'a':
                if stack[-1] == 'a':
                    stack.append(w)
                else:  # 其他情况重置字母栈，并添加一个'a'
                    stack = ['a', 'a']
            elif w == 'e':
                if stack[-1] == 'a' and len(stack) >= 2:
                    stack.append(w)
                elif stack[-1] == 'e':
                    stack.append(w)
                else:
                    stack = ['a']
            elif w == 'i':
                if stack[-1] == 'e' or stack[-1] == 'i':
                    stack.append(w)
                else:
                    stack = ['a']
            elif w == 'o':
                if stack[-1] == 'i' or stack[-1] == 'o':
                    stack.append(w)
                else:
                    stack = ['a']
            #elif w == 'u':
            else:
                if stack[-1] == 'o' or stack[-1] == 'u':
                    stack.append(w)
                else:
                    stack = ['a']
            if stack[-1] == 'u':
                result = max(result, len(stack) - 1)
        return result

class Solution:

    TRANSIT = {
        ("a", "e"), ("e", "i"), ("i", "o"), ("o", "u"),
        ("a", "a"), ("e", "e"), ("i", "i"), ("o", "o"), ("u", "u"),
        ("x", "a"), ("e", "a"), ("i", "a"), ("o", "a"), ("u", "a"),
    }

    def longestBeautifulSubstring(self, word: str) -> int:
        cur, ans = 0, 0
        status = "x"

        for ch in word:
            if (status, ch) in Solution.TRANSIT:
                if status != "a" and ch == "a":
                    cur = 1
                else:
                    cur = cur + 1
                status = ch
            else:
                cur = 0
                status = "x"
            if status == "u":
                ans = max(ans, cur)

        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-substring-of-all-vowels-in-order/solution/suo-you-yuan-yin-an-shun-xu-pai-bu-de-zu-9wqg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1011. 在 D 天内送达包裹的能力 20210426
传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。



示例 1：

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。
示例 2：

输入：weights = [3,2,2,4,1,4], D = 3
输出：6
解释：
船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
第 1 天：3, 2
第 2 天：2, 4
第 3 天：1, 4
示例 3：

输入：weights = [1,2,3,1,1], D = 4
输出：3
解释：
第 1 天：1
第 2 天：2
第 3 天：3
第 4 天：1, 1


提示：

1 <= D <= weights.length <= 50000
1 <= weights[i] <= 500


二分查找的初始左右边界应当如何计算呢？

对于左边界而言，由于我们不能「拆分」一个包裹，因此船的运载能力不能小于所有包裹中最重的那个的重量，即左边界为数组 \textit{weights}weights 中元素的最大值。
对于右边界而言，船的运载能力也不会大于所有包裹的重量之和，即右边界为数组 \textit{weights}weights 中元素的和。



class Solution:
    def shipWithinDays(self, weights: List[int], D: int) -> int:
        # 确定二分查找左右边界
        # 包裹不能拆分，所以最小运载能力不能小于所有包裹中最重的那个的重量
        # 天数最低一天，最大运载能力不会大于所有包裹的重量之和
        left, right = max(weights), sum(weights)
        while left < right:
            middle = (left + right) // 2
            # 需要运送的天数 day，当天已经运送包裹的重量之和 weight
            day, weight = 1, 0
            for w in weights:
                if w + weight > middle:
                    weight = 0
                    day += 1
                weight += w
            # 如果所需天数小与等于预设天数，说明 middle 值太大了，即最大运载能力 right 小于等于 middle
            # 否则说明 middle 值太小的，即最小运载能力lelf 大于等于 middle + 1
            if day <= D:
                right = middle
            else:
                left = middle + 1

        return left

表格笔记：
row_tuple = ws1.iter_rows(min_row=2)
# row_tuple = ws1.rows
# next(row_tuple)  # 生成器跳过第一行表头，从第二行读取数据

938. 二叉搜索树的范围和
给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。



示例 1：


输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32
示例 2：


输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出：23


提示：

树中节点数目在范围 [1, 2 * 104] 内
1 <= Node.val <= 105
1 <= low <= high <= 105
所有 Node.val 互不相同

class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        if not root:
            return 0
        if root.val > high:
            return self.rangeSumBST(root.left, low, high)
        if root.val < low:
            return self.rangeSumBST(root.right, low, high)
        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-of-bst/solution/er-cha-sou-suo-shu-de-fan-wei-he-by-leet-rpq7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        total = 0
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if not node:
                continue
            if node.val > high:
                q.append(node.left)
            elif node.val < low:
                q.append(node.right)
            else:
                total += node.val
                q.append(node.left)
                q.append(node.right)

        return total

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-of-bst/solution/er-cha-sou-suo-shu-de-fan-wei-he-by-leet-rpq7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        self.cur = 0
        def dfs(node):
            if node.left:
                dfs(node.left)
            if node.val > high:
                return
            if node.val >= low:
                self.cur += node.val
            if node.right:
                dfs(node.right)
        dfs(root)
        return self.cur

作者：AC_OIer
链接：https://leetcode-cn.com/problems/range-sum-of-bst/solution/gong-shui-san-xie-yi-ti-shuang-jie-di-gu-q2fo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rangeSumBST(self, root, low, high):
        res = 0
        if not root:
            return res
        res += self.rangeSumBST(root.left, low, high)
        if low <= root.val <= high:
            res += root.val
        res += self.rangeSumBST(root.right, low, high)
        return res

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/range-sum-of-bst/solution/fu-xue-ming-zhu-li-jie-di-gui-han-shu-de-hkmv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rangeSumBST(self, root, low, high):
        res = 0
        if not root:
            return res
        if root.val > low:
            res += self.rangeSumBST(root.left, low, high)
        if low <= root.val <= high:
            res += root.val
        if root.val < high:
            res += self.rangeSumBST(root.right, low, high)
        return res

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/range-sum-of-bst/solution/fu-xue-ming-zhu-li-jie-di-gui-han-shu-de-hkmv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

137. 只出现一次的数字 II  20210430
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。



示例 1：

输入：nums = [2,2,3,2]
输出：3
示例 2：

输入：nums = [0,1,0,1,0,1,99]
输出：99


提示：

1 <= nums.length <= 3 * 104
-231 <= nums[i] <= 231 - 1
nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次


进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

排序后遍历
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        nums.sort()
        if len(nums) == 1 or nums[0] != nums[1]:
            return nums[0]
        for i in range(1, len(nums) - 1):
            if nums[i - 1] != nums[i] and nums[i] != nums[i + 1]:
                return nums[i]
        return nums[len(nums) - 1]

哈希表
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        freq = collections.Counter(nums)
        ans = [num for num, occ in freq.items() if occ == 1][0]
        return ans

数字电路
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        a = b = 0
        for num in nums:
            a, b = (~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)
        return b

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        a = b = 0
        for num in nums:
            b = ~a & (b ^ num)
            a = ~b & (a ^ num)
        return b

136. 只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = []
        for n in nums:
            if n in res:
                res.remove(n)
            else:
                res.append(n)
        return res[0]

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1720. 解码异或后的数组 20210506
未知 整数数组 arr 由 n 个非负整数组成。

经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。

给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。

请解码返回原数组 arr 。可以证明答案存在并且是唯一的。



示例 1：

输入：encoded = [1,2,3], first = 1
输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
示例 2：

输入：encoded = [6,2,7,3], first = 4
输出：[4,2,0,7,4]


提示：

2 <= n <= 104
encoded.length == n - 1
0 <= encoded[i] <= 105
0 <= first <= 105

# 异或，值相同为0，抵消
# encoded[i] = arr[i] ^ arr[i + 1]
# encoded[i] ^ arr[i] = arr[i] ^ arr[i + 1] ^ arr[i]
# encoded[i] ^ arr[i] = arr[i + 1]

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        res = [first]
        cache = first
        for i in encoded:
            j = i ^ cache
            res.append(j)
            cache = j
        return res

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for num in encoded:
            arr.append(arr[-1] ^ num)
        return arr


class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        length = len(encoded)
        res = [first for _ in range(length + 1)]
        for i in range(length):
            res[i + 1] = encoded[i] ^ res[i]
        return res

1486. 数组异或操作 20210507
给你两个整数，n 和 start 。

数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。

请返回 nums 中所有元素按位异或（XOR）后得到的结果。



示例 1：

输入：n = 5, start = 0
输出：8
解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
     "^" 为按位异或 XOR 运算符。
示例 2：

输入：n = 4, start = 3
输出：8
解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.
示例 3：

输入：n = 1, start = 7
输出：7
示例 4：

输入：n = 10, start = 5
输出：2


提示：

1 <= n <= 1000
0 <= start <= 1000
n == nums.length

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        num = 0
        for i in range(n):
            num ^= start + 2 * i
        return num

数学法劝退（逃~


位运算符
32 // 8相当于32 >> 4

~x						按位取反
x<<y,x>>y			移位
x&y					按位与
x^y					按位异或
x|y					按位或

~(按位取反) <<(向左位移) >>(向右位移) &(位与) ^(异或) |(位或)


print(~7)  # output: "-8"

0000 0111 => 1111 1000 => 1000 1000 => -8

# 向左位移1，相当于乘以2；向右位移1，相当于除以2

print(4 << 1)  # output: "2"

0000 0100 => 0000 1000 => 2

print(4 >> 1)  # output: "2"

0000 0100 => 0000 0010 => 2

# 位与，同时为1，结果才为1，否则为0
即：1 & 1= 1 , 0 & 0= 0 , 0 & 1= 0 , 1 & 0= 0

print(4 & 6)  # output: "4"

0000 0100
0000 0110
0000 0100

# 异或，值不相同为1，否则为0
即：0 ^ 1= 1 , 1 ^ 0= 1 , 0 ^ 0= 0 , 1 ^ 1= 0

print(4 ^ 6)  # output: "2"

0000 0100
0000 0110
0000 0010



# 位或，只要有一个为1，结果就为1
即：0 | 1= 1 , 1 | 0= 1 , 1 | 1= 0 , 0 | 0= 0

print(4 | 6)  # output: "6"

0000 0100
0000 0110
0000 0110

异或可以用来，交换两个变量的值

a = a + b
b = a - b
a = a - b

a = 5
b = 1
a = a ^ b
print(a)
b = a ^ b
a = a ^ b
print(a, b)

任何数异或自己都为零，若任何数异或零都为自己
a = a ^ b
b = a ^ b = (a(初始) ^ b) ^ b = a(初始) ^ (b ^ b) = a(初始) ^ 0 = a(初始)
a = a ^ b = a ^ (a ^ b(初始)) = (a ^ a) ^ b(初始) = b(初始)



字符串前加 f
import time
t0 = time.time()
time.sleep(1)
name = 'processing'
# 以 f开头表示在字符串内支持大括号内的python 表达式
print(f'{name} done in {time.time() - t0:.2f} s') 


Python的PyYAML模块详解
https://blog.csdn.net/swinfans/article/details/88770119

# yml = yaml.dump(content)  # dump后的字典数据顺序，默认按首字母排序
# yml = yaml.dump(content, sort_keys=False)  # dump后的字典数据按原有顺序
# yml = yaml.dump(content, default_style="'")  # 生成的yaml所有标量使用"'"包裹，默认字符串标量不包裹
# yml = yaml.dump(content, sort_keys=False, indent=4, allow_unicode=True)  # 设置允许包含unicode字符(中文字符)


1723. 完成所有工作的最短时间 20210508
给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。

请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。

返回分配方案中尽可能 最小 的 最大工作时间 。



示例 1：

输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。
示例 2：

输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。


提示：

1 <= k <= jobs.length <= 12
1 <= jobs[i] <= 107

872. 叶子相似的树  20210510
请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。



举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。

如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。

如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。



示例 1：



输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出：true
示例 2：

输入：root1 = [1], root2 = [1]
输出：true
示例 3：

输入：root1 = [1], root2 = [2]
输出：false
示例 4：

输入：root1 = [1,2], root2 = [2,2]
输出：true
示例 5：



输入：root1 = [1,2,3], root2 = [1,3,2]
输出：false


提示：

给定的两棵树可能会有 1 到 200 个结点。
给定的两棵树上的值介于 0 到 200 之间。

class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
        def dfs(node: TreeNode):
            if not node.left and not node.right:
                yield node.val
            else:
                if node.left:
                    yield from dfs(node.left)
                if node.right:
                    yield from dfs(node.right)

        seq1 = list(dfs(root1)) if root1 else list()
        seq2 = list(dfs(root2)) if root2 else list()
        return seq1 == seq2

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/leaf-similar-trees/solution/xie-zi-xiang-si-de-shu-by-leetcode-solut-z0w6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



1734. 解码异或后的排列 20210511
给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。

它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。

给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。



示例 1：

输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
示例 2：

输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]


提示：

3 <= n < 105
n 是奇数。
encoded.length == n - 1





class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        n = len(encoded) + 1
        total = reduce(xor, range(1, n + 1))
        odd = 0
        for i in range(1, n - 1, 2):
            odd ^= encoded[i]

        perm = [total ^ odd]
        for i in range(n - 1):
            perm.append(perm[-1] ^ encoded[i])

        return perm

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/decode-xored-permutation/solution/jie-ma-yi-huo-hou-de-pai-lie-by-leetcode-9gw4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

12. 整数转罗马数字 20210514
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。



示例 1:

输入: num = 3
输出: "III"
示例 2:

输入: num = 4
输出: "IV"
示例 3:

输入: num = 9
输出: "IX"
示例 4:

输入: num = 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.
示例 5:

输入: num = 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.


提示：

1 <= num <= 3999

方法一：模拟
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]

    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                num -= value
                roman.append(symbol)
            if num == 0:
                break
        return "".join(roman)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-to-roman/solution/zheng-shu-zhuan-luo-ma-shu-zi-by-leetcod-75rs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

方法二：硬编码数字
class Solution:

    THOUSANDS = ["", "M", "MM", "MMM"]
    HUNDREDS = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]
    TENS = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]
    ONES = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]

    def intToRoman(self, num: int) -> str:
        return Solution.THOUSANDS[num // 1000] + \
            Solution.HUNDREDS[num % 1000 // 100] + \
            Solution.TENS[num % 100 // 10] + \
            Solution.ONES[num % 10]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-to-roman/solution/zheng-shu-zhuan-luo-ma-shu-zi-by-leetcod-75rs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

993. 二叉树的堂兄弟节点
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。

如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。

只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。



示例 1：


输入：root = [1,2,3,4], x = 4, y = 3
输出：false
示例 2：


输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
示例 3：



输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false


提示：

二叉树的节点数介于 2 到 100 之间。
每个节点的值都是唯一的、范围为 1 到 100 的整数。


class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x 的信息
        x_parent, x_depth, x_found = None, None, False
        # y 的信息
        y_parent, y_depth, y_found = None, None, False

        def dfs(node: TreeNode, depth: int, parent: TreeNode):
            if not node:
                return

            nonlocal x_parent, y_parent, x_depth, y_depth, x_found, y_found

            if node.val == x:
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                y_parent, y_depth, y_found = parent, depth, True

            # 如果两个节点都找到了，就可以提前退出遍历
            # 即使不提前退出，对最坏情况下的时间复杂度也不会有影响
            if x_found and y_found:
                return

            dfs(node.left, depth + 1, node)

            if x_found and y_found:
                return

            dfs(node.right, depth + 1, node)

        dfs(root, 0, None)
        return x_depth == y_depth and x_parent != y_parent

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-mfh2d/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        # x 的信息
        x_parent, x_depth, x_found = None, None, False
        # y 的信息
        y_parent, y_depth, y_found = None, None, False

        # 用来判断是否遍历到 x 或 y 的辅助函数
        def update(node: TreeNode, parent: TreeNode, depth: int):
            if node.val == x:
                nonlocal x_parent, x_depth, x_found
                x_parent, x_depth, x_found = parent, depth, True
            elif node.val == y:
                nonlocal y_parent, y_depth, y_found
                y_parent, y_depth, y_found = parent, depth, True

        q = collections.deque([(root, 0)])
        update(root, None, 0)

        while q:
            node, depth = q.popleft()
            if node.left:
                q.append((node.left, depth + 1))
                update(node.left, node, depth + 1)
            if node.right:
                q.append((node.right, depth + 1))
                update(node.right, node, depth + 1)

            if x_found and y_found:
                break

        return x_depth == y_depth and x_parent != y_parent

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/cousins-in-binary-tree/solution/er-cha-shu-de-tang-xiong-di-jie-dian-by-mfh2d/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。